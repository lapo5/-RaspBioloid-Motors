#!/usr/bin/env python

import rospy
import sys
import dynamixel_sdk as sdk
from motors.msg import *

def motor_monitor():
	rospy.init_node('motor_monitor', anonymous=True)

	pub = []
	portHandler = sdk.PortHandler("/dev/ttyACM0")
	packetHandler = sdk.PacketHandler(1.0)
	portHandler.openPort()
	portHandler.setBaudRate(1000000)
	
	cont=2
	for i in range(1, cont+1):
		pub.append(rospy.Publisher('motors_info/%d' % i, MotorMsg, queue_size=2))
		packetHandler.writeTxRx(port = portHandler,
								dxl_id = i, 
								address = 5, # RETURN DELAY TIME
								length = 1, 
								data = [0])  # VALUE: 0us
		packetHandler.writeTxRx(port = portHandler,
								dxl_id = i, 
								address = 24, #TORQUE ENABLE
								length = 1,
								data = [1]) #VALUE: ON
	motor_msg = MotorMsg()

	#rate = rospy.Rate(1000)
	while not rospy.is_shutdown():
		for i in range(1, cont+1):
			data, _, _ = packetHandler.readTxRx(port = portHandler,
												dxl_id = i, 
												address = 36, # POSITION | SPEED | LOAD
												length = 6)

			pos = sdk.DXL_MAKEWORD(data[0], data[1])
			speed = sdk.DXL_MAKEWORD(data[2], data[3])
			load = sdk.DXL_MAKEWORD(data[4], data[5])

			motor_msg.Pos = pos
			motor_msg.Speed = speed if speed < 1024 else 1024-speed
			motor_msg.Load = load if load < 1024 else 1024-load

			pub[i-1].publish(motor_msg)
			
		#rate.sleep()


	# spin() simply keeps python from exiting until this node is stopped
	rospy.spin()

if __name__ == '__main__':
	motor_monitor()
